# ===============================
# Hashing Assignment Solutions (Python)
# ===============================

#--------------------------------
#1. Implement linear probing
#--------------------------------
class LinearProbingHash:
    def __init__(self, size=7):
        self.size = size; self.table = [None]*size
    def insert(self, key):
        idx = key % self.size
        for i in range(self.size):
            j = (idx+i) % self.size
            if self.table[j] is None:
                self.table[j] = key; return True
        return False

#--------------------------------
#2. Implement separate chaining
#--------------------------------
class ChainingHash:
    def __init__(self, size=7):
        self.size = size; self.table = [[] for _ in range(size)]
    def insert(self, key):
        self.table[key%self.size].append(key)

#--------------------------------
#3. Count distinct elements in every window
#--------------------------------
from collections import defaultdict, Counter
def countDistinctWindow(arr, k):
    freq = defaultdict(int); res = []
    for i, val in enumerate(arr):
        freq[val]+=1
        if i>=k:
            freq[arr[i-k]]-=1
            if freq[arr[i-k]]==0: del freq[arr[i-k]]
        if i>=k-1: res.append(len(freq))
    return res

#--------------------------------
#4. Find duplicates in array
#--------------------------------
def findDuplicates(arr):
    c = Counter(arr)
    return [k for k,v in c.items() if v>1]

#--------------------------------
#5. Longest consecutive subsequence
#--------------------------------
def longestConsecutive(nums):
    s=set(nums); ans=0
    for x in nums:
        if x-1 not in s:
            y=x
            while y in s: y+=1
            ans=max(ans,y-x)
    return ans

#--------------------------------
#6. Check if pair with given sum exists
#--------------------------------
def hasPairWithSum(arr, target):
    seen=set()
    for x in arr:
        if target-x in seen: return True
        seen.add(x)
    return False

#--------------------------------
#7. Count pairs with given sum
#--------------------------------
def countPairsSum(arr, target):
    c=Counter(arr); ans=0
    for x in list(c.keys()):
        y=target-x
        if y not in c: continue
        if x==y: ans+=c[x]*(c[x]-1)//2
        elif x<y: ans+=c[x]*c[y]
    return ans

#--------------------------------
#8. Zero sum subarrays
#--------------------------------
def zeroSumSubarrays(arr):
    pref=0; c=defaultdict(int); c[0]=1; ans=0
    for x in arr:
        pref+=x
        ans+=c[pref]
        c[pref]+=1
    return ans

#--------------------------------
#9. Itinerary from tickets
#--------------------------------
def findItinerary(tickets, start):
    from collections import defaultdict
    g=defaultdict(list)
    for a,b in tickets: g[a].append(b)
    for k in g: g[k].sort(reverse=True)
    stack=[start]; res=[]
    while stack:
        while g[stack[-1]]: stack.append(g[stack[-1]].pop())
        res.append(stack.pop())
    return res[::-1]

#--------------------------------
#10. Hackerrank: Ransom Note
#--------------------------------
def canConstructRansom(mag, note):
    cm=Counter(mag.split()); cn=Counter(note.split())
    for w,c in cn.items():
        if cm[w]<c: return False
    return True